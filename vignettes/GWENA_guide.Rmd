---
title: "GWENA - Guide"
author: "Gwenaëlle Lemoine"
date: "`r Sys.Date()`"
output: 
  # rmarkdown::html_vignette: 
  #   toc: true
  prettydoc::html_pretty:
    theme: cayman
    toc: true
vignette: >
  %\VignetteIndexEntry{GWENA-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>",
  cache = TRUE
)
```

*Citation: TODO quand la ref + DOI de la publi sera dispo*

## Overview

Comprehension of complex biological systems now require an approach based on interactions between each actor, meaning a network. Their interpretation often involve both a knowledge-driven and a data driven analysis. Current methods respectively focus on functional enrichment and hub genes detection. Combining them with the comparison of conditions and an extended topology analysis within a single pipeline can lead to better results exploitation. 

This document gives an overview of the R package **GWENA** (Gene Whole co-Expression Network Analysis) which regroups this process into a single pipeline and tool to ease the work of bioinformaticians in their analysis of multiple conditions through the co-expression spectrum, therefore helping the discovery of meaningful biological conclusions.

Current pipeline involves steps in Figure 1 and will be detailed in each following section.

.

> ![Figure 1. Analysis pipeline for GWENA, from raw data to full characterization of the modules and comparison of conditions.](figure_pipeline_schema.png)

<!-- It can be performed using the function wrapping all steps `TODO nom fonction full analysis`, or using each function for each step. -->


## Loading

```{r, message=FALSE, warning=FALSE}
library(GWENA)
library(magrittr)
```

<!-- ## Quick start  -->
<!-- `# TODO : script avec fonction full analysis` -->

<!-- ```{r setup, eval = FALSE} -->
<!-- # TODO: ajouter wrapper -->
<!-- ``` -->

## Main steps detail with default pipeline

### 1. Input data

Input data supported by this package can be either from RNA-seq or microarray. You can use the import function of your choice (read.csv, read.table, ect.) as long as the final format is a data.frame with genes as columns and samples as rows. Transcriptomic data must have been resumed to the gene level (if you have no idea how to do so, see [How can I resume my transcriptomic data to the gene level ?](FAQ.html/#how-can-i-resume-my-transcriptomic-data-to-the-gene-level) from the [FAQ](FAQ.html)) . 

<!-- TODO Si le package n'implémente pas de méthode, laisser cette phrase et la compléter en indiquant dans la section en question les moyens de résumé à l'échelle gene comme collapseRows de WGCNA, ou ... ? RSEM ? RNA-SeQC ? etc. -->

In this vignette, we will be using the transcriptomic dataset [GSE85358](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85358) from the [Kuehne et al. study](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-017-3547-3) and the associated phenotipic traits matrix. Data has been processed along with the R script given in Additionnal data n°10 and will be our example data set here. The aim of this study was the investigation of the roles of transcriptomics, metabolomics and their junction in skin aging.

* Transcriptomic data type: microarray (Agilent-039494 SurePrint G3 Human GE v2 8x60K, mono channel)
* `r ncol(kuehne_expr)` genes
* `r nrow(kuehne_expr)` samples
* `r length(table(kuehne_traits$Condition))` conditions : `r unique(kuehne_traits$Condition)[1]` et `r unique(kuehne_traits$Condition)[2]`

```{r data_input}
kuehne_expr[1:5,1:5]

kuehne_traits[1:5,]
```

> Note : GWENA doesn't provide normalization methods. Explaination can be found in FAQ at [Why GWENA doesn't provide normalization methods ?](FAQ.html/#)

### 2. Gene filtering

Even if co-expression method will filter out low co-expressed genes, it is interesting in terms of computer power to reduce the dataset to work with. This will require less memory to store the data, and less CPU power and memory when working on it. Howerver, this step need to be carefully studied as it will impact the modules building. 

The [authors of WGCNA advise against using differentialy expressed (DE) genes](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html) as a filter since the tool is based on unsupervised clustering. Moreover, using DE genes will broke the scale-free property (small-world network) on which the adjacency matrix is calculated.

Multiple types of filtration have been natively implemented :

* For all :
  * Filtration on low variation
* For RNA-seq data :
  * at least one : only one sample need to have a value above min_count in the gene
  * mean : the mean of all samples for the gene need to be above min_count
  * all : all samples for the gene need to be above min_count
* For microarray
  * TODO

<!-- Remettre le TODO sous For all car il faudra ajouter d'autres méthodes de filtration ? -->

In this example, we'll be filtering the low variating genes.

```{r filtration}
kuehne_expr_filtered <- filter_low_var(kuehne_expr, pct = 0.7, type = "median")
```

Remaining number of genes : `r ncol(kuehne_expr_filtered)`

<!-- ```{r plot_expr} -->
<!-- library(ggplot2) -->
<!-- tit = kuehne_expr %>% t %>% -->
<!--   apply(1, var) %>% -->
<!--   data.frame(gene = names(.), var_nofilter = .) %>% -->
<!--   bind_cols(kuehne_expr_filtered %>% t %>% -->
<!--               apply(1, var) %>% -->
<!--               data.frame(gene = names(.), var_filter = .)) %>% -->
<!--   tibble::rownames_to_column(var = gene) %>% -->
<!--   tidyr::pivot_longer(-gene, names_to = "filter", values_to = "variation") %>% -->
<!--   ggplot(aes(x = variation, colour = filter)) + geom_density()  -->


<!-- tut <- kuehne_expr %>%  -->
<!--   tibble::rownames_to_column(var = "sample") %>% -->
<!--   tidyr::pivot_longer(-sample, names_to = "gene", values_to = "expression") -->
<!-- ggplot(tut, aes(expression, colour = sample)) + geom_density() -->
<!-- ``` -->



### 3. Network building 

Gene co-expression networks consist in an ensemble of genes (nodes) linked to each other (edges) according to the strengh of their relation. This strengh estimation begins by the computation of a **similarity score**. It can be a distance (euclidian, minkowski, ...) but is usually a correlation. Among these, Pearson's one is the more popular. However in GWENA we chosed Spearman correlation by default since it is less sensible to outliers which are frequent in transcriptomics.

This first score can then be adjusted to reflect the reality. It's the case of WGCNA which base its adjustement on the [scale-free](https://en.wikipedia.org/wiki/Scale-free_network) property of gene networks. The distribution of the nodes degree in these networks follows a power law. Next step consists to select the best fitting power law to the correlations, so they can be adjusted by it in the end.

Another adjustement takes into account the [topology of the network](https://en.wikipedia.org/wiki/Network_topology). It holds trails to understand the underlying biological processes. In this case, it's the topological overlap[^1] of two nodes which is used to reflect it.

<!-- The built of our co-expression network goes through this sub-steps : -->
<!-- 1. Computing correlation between each pair of genes. -->
<!-- 2. Trying to fit a power law to the distribution of this correlations to adjust them by it. This results in a similarity score for each pair of genes. -->
<!-- 3. This score is itselft re-adjust by taking into acount the topology of the network. -->

```{r net_building}
# In order to fasten the example process here, we only take a sample of the genes
kuehne_expr_filtered <- kuehne_expr_filtered[, 1:1000]

net <- build_net(kuehne_expr_filtered, cor_func = "spearman")
```

* Power selected : `r net$metadata$power`
* Fit of the power law to data ($R^2$) : `r net$metadata$fit_power_table[net$metadata$fit_power_table$Power == net$metadata$power, "SFT.R.sq"]`

### 4. Modules detection

At this point, our network is a [complete graph](https://en.wikipedia.org/wiki/Complete_graph) : all nodes are connected to all other nodes with different strengh. Some strong links are often localized around the same genes, allowing to observe groups of genes closely related. In co-expression networks this groups are called modules and assumed to be representatives of genes working together to a same set of function.

They can be detected using unsupervised learning (here hierarchical clustering) or other adapted clustering method. 

```{r modules_detection}
detection <- detect_modules(kuehne_expr_filtered, net$network, merge_cut_height = 0.997, detailled_result = TRUE)
```

Since this operation tend to create multiple little modules with highly similar expression profile (based on the [eigengene](FAQ.html/#what-is-an-eigengene) of each), they are ussually merged into one.

* Number of modules before merging : `r length(unique(detection$modules_premerge))-1` 
* Number of modules after merging : `r length(unique(detection$modules))-1`

```{r bipartite_graph_merge}
plot_modules_merge(modules_premerge = detection$modules_premerge, modules_merged = detection$modules)
```

Resulting modules contain more genes whose repartition can be seen by a simple barplot. Noticebly, WGCNA tend to create bigger modules for the first ones and smaller for the latest. 

```{r plot_modules_gene_distribution, fig.height=3}
ggplot2::ggplot(data.frame(detection$modules %>% stack), ggplot2::aes(x = ind)) + ggplot2::stat_count() +
  ggplot2::ylab("Number of genes") +
  ggplot2::xlab("Module")
```

<!-- As explain before, each module regroups genes which have a strong similarity. This means the expression profiles are also similar, as shown below. -->
Each of the modules present a specific profile, which can be plotted in two figures to separate the positive (+ facet) and negative (- facet) correlations profile. As a summary of this profiles, an eigengene (red line) acting like a signature can be stacked on this representation. 

```{r plot_module_profile}
plot_expression_profiles(kuehne_expr_filtered, detection$modules)
```

These informations along to the genes sets inside modules are now usefull to relate external gene information, or more generally, biological information.


### 5. Biological integration

#### 5.1. Functionnal enrichment

A popular way to explore the modules consist to link know biological gene sets to it. Among the available ones, Gene Ontology (GO) and the Kyoto Encyclopedia of Genes and Genomes (KEGG) are the more used. Along with WikiPathways, Reactome, Human Phenotype Ontology (HPO), they give a systemic aspects to the gene sets from the modules. In oppositions, references like TRANSFAC, miRTarBase, Human Protein Atlas (HPA), and CORUM give a more linear point of view but with a larger scale information like tissue/cell/condition information.

Using the over-representation analysis (ORA) function GOSt implemented in the g:Profiler tool, we can retieve the biological association for each module and plot it as follow.

```{r modules_enrichment}
enrichment <- bio_enrich(detection$modules)
plot_enrichment(enrichment)
```

In these module, the functionnal activity seems to be linked to the processes of membrane communication. Moreover, the type of processes suggest an activity about cell cycle of life (differentiation, autophagy and content degradation).

#### 5.2. Phenotypic association

If phenotypic informations are available about the samples provided, an association test can help to determine if a module is specifically linked to a trait. In this cas, the module 1 seems to be strongly linked to the `Age` trait.

```{r modules_phenotype}
phenotype_association <- associate_phenotype(detection$modules_eigengenes, 
                                             kuehne_traits %>% select(Condition, Age, Slide))
plot_modules_phenotype(phenotype_association)
```

The combination of information with the previous functionnal enrichment can orientate further analysis. Aging is a condition related to the variations of the cell potential : the progressive degradation of quality in cell proliferation and differentiation is the first steps towards malfunctions which induce tissue degradation. Multiple genes are known to be affected or related to these mechanisms, however they can't fully explain this phenomenon. 

<!-- ### 5.3. Differentially expressed genes (maybe ?) -->

### 6. Graph analysis

<!-- missing informations -->
<!-- looking to neighboor genes -->
<!-- adding data driven information with less bias -->
<!-- hubgenes -->

<!-- Alternative text -->
<!-- To recover this missing information, a common method in co-expression analysis is to use topology information. Neighborhood genes, patterns of interactions and other graph infromations can retrieve information yet to be biologicaly confirmed. Neighborhood genes have already be founded to be regulators or indirect factors of a condition (like gene-coded protein which would be catalyzed and from whom the product would impact the condition).  -->

To recover this missing information, a common method is to look to the genes linked to the known one inside co-expression networks. These neighborhood genes may act as regulators or indirect factors of the condition (like gene-coded protein which would be catalyzed and from whom the product would impact the condition). Multiple metrics, in the sens of graph theory, exist to assess the closely lineked genes.
Moreover, information can itself come from the network, meaning data-driven information, by opposition to the functionnal enrichment which is knowledge driven (information from biological databases is "matched" onto studied data). For example, hub genes are genes which are central in the network in terms of centrality and 

Manipulation of graph objects can be quite demanding in memory and CPU usage. Caution is advised when choosing to plot the whole network if it is larger than 100 genes (therefore nodes). 

For this reason it is a good practice to plot only interesting modules. The module 1 from our example present a significant link to aging based on phenotype association and also many terms of biological enrichment. We will continue our topological analysis with it.
Since co-expression network are complete graph, all nodes are connected with each other even if the strengh of the link is weak (at the module scale, not the network). In order to remove this noise and bring some clarity in visualisation, this links below a threshold are removed.

```{r graph}
module_1 <- detection$modules$`1`
graph <- build_graph_from_sq_mat(net$network[module_1, module_1])
plot_module(graph, weight_th = 0.99, edge_scaling = 0.1, node_scaling = 0.5)
```

As you can see, adjustments on node size and edges width can be applied to improve clarity

Inside the module are genes which are key genes in the biological functions covered. This are called "hub genes". In order to detect them, multiple algorithms are available:

* Highest connectivity: Select the top n (n depending on parameter given) highest connected genes. Similar to WGCNA's selection of hub genes
* Superior degree: Select genes which degree is greater than average connection degree of the network. Definition from network theory.
* Kleinberg's score: Select genes which Kleinberg's score superior to provided threshold.











## Main steps detail with change in pipeline's modules









<div style="text-align:center; font-size:70%; margin-top:50px"> 
  ______
  If you have any question or misunderstanding, take a look at GWENA's general documentation (`package?GWENA`) or send an email to lemoine.gwenaelle[@t)gmail{d0t]com
</div>

<!-- ______ -->

[^1]: [RAVASZ, Erzsébet, SOMERA, Anna Lisa, MONGRU, Dale A., et al. Hierarchical organization of modularity in metabolic networks. science, 2002, vol. 297, no 5586, p. 1551-1555.](https://doi.org/10.1126/science.1073374)
