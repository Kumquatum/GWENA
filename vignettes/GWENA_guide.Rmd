---
title: "GWENA package guide"
author: "Gwenaëlle Lemoine"
date: "`r Sys.Date()`"
output: 
  # rmarkdown::html_vignette: 
  #   toc: true
  prettydoc::html_pretty:
    theme: cayman
    toc: true
vignette: >
  %\VignetteIndexEntry{GWENA-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>",
  cache = TRUE
)
```

GWENA is a pipeline performing a co-expression analysis and helping to its biological interpretation through multiple side analysis.

```{r, message=FALSE, warning=FALSE}
library(GWENA)
library(dplyr)
```


Steps are described in the figure below and will be detailed in each following section.
![pipeline_schema](figure_pipeline_schema.png)


It can be performed using the function wrapping all steps `TODO nom fonction full analysis`, or using each function for each step.

## 0. Quick start 
`# TODO : script avec fonction full analysis`




```{r setup, eval = FALSE}
# TODO: ajouter wrapper
```


## 1. Input data

Data can be either from RNA-seq or microarray. They must have been resumed to the gene level (if you have no idea how to do so, see the "Resuming at gene level" section) 

> Si le package n'implémente pas de méthode, laisser cette phrase et la compléter en indiquant dans la section en question les moyens de résumé à l'échelle gene comme collapseRows de WGCNA, ou ... ? RSEM ? RNA-SeQC ? etc.

[GSE85358](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85358) is a data set from [Kuehne and al. study](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-017-3547-3). It has been processed along R script given in supplementary data and will be our example data set here.

Informations about data set :

* Context: skin aging
* Data type: microarray
* `r ncol(kuehne_expr)` genes
* `r nrow(kuehne_expr)` samples
* `r length(table(kuehne_traits$Condition))` conditions : `r unique(kuehne_traits$Condition)[1]` et `r unique(kuehne_traits$Condition)[2]`

```{r data_input}
kuehne_expr[1:5,1:5]

kuehne_traits[1:5,]
```

## 2. Filtration

This step need to be carefully studied as it will impact the modules building. 
The authors of WGCNA advise against using differentialy expressed (DE) genes as a filter since the tool is based on unsupervised clustering. Moreover, using DE genes will broke the scale-free property (small-world network) on which the adjacency matrix is calculated.

Multiple types of filtration have been natively implemented :

* For all :
  * Filtration on low variation
  * TODO
* For RNA-seq data :
  * at least one : only one sample need to have a value above min_count in the gene
  * mean : the mean of all samples for the gene need to be above min_count
  * all : all samples for the gene need to be above min_count
* For microarray
  * TODO

```{r filtration}
kuehne_expr_filtered <- filter_low_var(kuehne_expr, pct = 0.7, type = "median")

# TODO: plot de la variation (avec ou sans fonction intégrée au package ?)

# Remaining number of genes
ncol(kuehne_expr_filtered)

# In order to fasten the example process here, we only take a sample of the genes
kuehne_expr_filtered <- kuehne_expr_filtered[, 1:1000]
```

## 3. Network building and modules detection

```{r net_building}
net <- net_building(kuehne_expr_filtered, cor_func = "spearman", detailled_result = TRUE)
```

* Power selected : `r net$power`
* Fit of the power law to data ($R^2$) : `r net$fit_power`

## 4. Modules detection

```{r modules_detection}
detection <- modules_detection(kuehne_expr_filtered, net$tom, detailled_result = TRUE)
```

* Number of modules before merging : `r length(unique(detection$modules_premerge))-1` 
* Number of modules after merging : `r length(unique(detection$modules))-1`
* Modules profiles

```{r plot_modules_repartition}
barplot(table(detection$modules)[-1], xlab = "Modules", ylab = "Number of genes")
```

## 5. Biological integration

### 5.1. Functionnal enrichment

```{r modules_enrichment}
library(gprofiler2)
enrichment <- modules_enrichment(detection$modules)
```

* Example of  module 2 enrichment plot
```{r plot_enrichment, message = FALSE}
gprofiler2::gostplot(enrichment$`2`)
```

### 5.2. Phenotypic association

```{r modules_phenotype}
phenotype_association <- modules_phenotype(detection$modules_eigengenes, kuehne_traits %>% select(Condition, Age, Slide))
```

```{r plot_modules_phenotype}
plot_modules_phenotype(phenotype_association)
```

<!-- ### 5.3. Differentially expressed genes (maybe ?) -->

## 6. Graph analysis

```{r graph}
# TODO

```


## 7. Modules comparison

```{r redo_by_condition}
kuehne_traits$sample = apply(kuehne_traits, 1, function(line) paste(line["Slide"], line["Exp"], sep = "_"))
data_list <- list(
  kuehne_young = kuehne_expr_filtered[rownames(kuehne_expr_filtered) %in% kuehne_traits[which(kuehne_traits$Condition == "young"), "sample"],],
  kuehne_old = kuehne_expr_filtered[rownames(kuehne_expr_filtered) %in% kuehne_traits[which(kuehne_traits$Condition == "old"), "sample"],]  
)

net_list <- lapply(data_list, net_building, kuehne_expr_filtered, cor_func = "spearman", save_adjacency = TRUE, detailled_result = TRUE)
detection_list <- mapply(modules_detection, data_list, lapply(net_list, function(condition) condition$tom), SIMPLIFY = FALSE)
```

```{r modules_preservation}
preservation <- modules_preservation(data_list, net_list, detection_list, "kuehne_young", "kuehne_old")
preserved_modules <- which(apply(preservation$p.value, 1, max) < 0.999) # Fake value here, just to show the result
```

* Preservation statistics

`r knitr::kable(preservation$p.values)`

* Modules preserved : `r paste(preserved_modules, collapse = ", ")`




______

If you have any question or misunderstanding, take a look at GWENA's general documentation (package?GWENA) or send an email to lemoine.gwenaelle[@t)gmail{d0t]com
