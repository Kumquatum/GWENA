---
title: "GWENA - Guide"
author: "Gwenaëlle Lemoine"
date: "`r Sys.Date()`"
output: 
  # rmarkdown::html_vignette: 
  #   toc: true
  prettydoc::html_pretty:
    theme: cayman
    toc: true
vignette: >
  %\VignetteIndexEntry{GWENA-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>",
  cache = TRUE
)
```

*Citation: TODO quand le DOI de la publi sera dispo*

## Presentation

Comprehension of complex biological systems now require an approach based on interactions between each actor, meaning a network. Their interpretation often involve both a knowledge-driven and a data driven analysis. Current methods respectively focus on functional enrichment and hub genes detection. Combining them with the comparison of conditions and an extended topology analysis within a single pipeline can lead to better results exploitation. 

This document gives an overview of the R package **GWENA** (Gene Whole co-Expression Network Analysis) which regroups this process into a single pipeline and tool to ease the work of bioinformaticians in their analysis of multiple conditions through the co-expression spectrum, therefore helping the discovery of meaningful biological conclusions.

Current pipeline involves steps in Figure 1 and will be detailed in each following section.

.

![pipeline_schema](figure_pipeline_schema.png)

> Figure 1.

<!-- It can be performed using the function wrapping all steps `TODO nom fonction full analysis`, or using each function for each step. -->


## Loading

```{r, message=FALSE, warning=FALSE}
library(GWENA)
```

<!-- ## Quick start  -->
<!-- `# TODO : script avec fonction full analysis` -->

<!-- ```{r setup, eval = FALSE} -->
<!-- # TODO: ajouter wrapper -->
<!-- ``` -->

## Steps detail

### 1. Input data

Input data supported by this package can be either from RNA-seq or microarray. They must have been resumed to the gene level (if you have no idea how to do so, see [How can I resume my transcriptomic data to the gene level ?](FAQ.html/#how-can-i-resume-my-transcriptomic-data-to-the-gene-level) from the [FAQ](FAQ.html)) . 

<!-- TODO Si le package n'implémente pas de méthode, laisser cette phrase et la compléter en indiquant dans la section en question les moyens de résumé à l'échelle gene comme collapseRows de WGCNA, ou ... ? RSEM ? RNA-SeQC ? etc. -->

In this vignette, we will be using the dataset [GSE85358](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85358) which come from [Kuehne and al. study](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-017-3547-3). It has been processed along the R script given in Additionnal data n°10 and will be our example data set here. The aim in this study was to investigate the role of the transcriptomics, the metabolomics and the junction of them in the skin aging.

* Data type: microarray
* `r ncol(kuehne_expr)` genes
* `r nrow(kuehne_expr)` samples
* `r length(table(kuehne_traits$Condition))` conditions : `r unique(kuehne_traits$Condition)[1]` et `r unique(kuehne_traits$Condition)[2]`

```{r data_input}
kuehne_expr[1:5,1:5]

kuehne_traits[1:5,]
```

### 2. Filtration

This step need to be carefully studied as it will impact the modules building. 
The authors of WGCNA advise against using differentialy expressed (DE) genes as a filter since the tool is based on unsupervised clustering. Moreover, using DE genes will broke the scale-free property (small-world network) on which the adjacency matrix is calculated.

Multiple types of filtration have been natively implemented :

* For all :
  * Filtration on low variation
* For RNA-seq data :
  * at least one : only one sample need to have a value above min_count in the gene
  * mean : the mean of all samples for the gene need to be above min_count
  * all : all samples for the gene need to be above min_count
* For microarray
  * TODO

<!-- Remettre le TODO sous For all car il faudra ajouter d'autres méthodes de filtration ? -->

In this example, we'll be filtering the low variating genes.

```{r filtration}
kuehne_expr_filtered <- filter_low_var(kuehne_expr, pct = 0.7, type = "median")
```

Remaining number of genes : `r ncol(kuehne_expr_filtered)`

<!-- ```{r plot_expr} -->
<!-- library(ggplot2) -->
<!-- tit = kuehne_expr %>% t %>% -->
<!--   apply(1, var) %>% -->
<!--   data.frame(gene = names(.), var_nofilter = .) %>% -->
<!--   bind_cols(kuehne_expr_filtered %>% t %>% -->
<!--               apply(1, var) %>% -->
<!--               data.frame(gene = names(.), var_filter = .)) %>% -->
<!--   tibble::rownames_to_column(var = gene) %>% -->
<!--   tidyr::pivot_longer(-gene, names_to = "filter", values_to = "variation") %>% -->
<!--   ggplot(aes(x = variation, colour = filter)) + geom_density()  -->


<!-- tut <- kuehne_expr %>%  -->
<!--   tibble::rownames_to_column(var = "sample") %>% -->
<!--   tidyr::pivot_longer(-sample, names_to = "gene", values_to = "expression") -->
<!-- ggplot(tut, aes(expression, colour = sample)) + geom_density() -->
<!-- ``` -->



### 3. Network building and modules detection

Gene co-expression networks consist in an ensemble of genes (nodes) linked to each other (edges) according to the strengh of their relation. This strengh estimation begins by the computation of a **similarity score**. It can be a distance (euclidian, minkowski, ...) but is usually a correlation. Among these, Pearson's one is the more popular. However in GWENA we chosed Spearman correlation by default since it is less sensible to outliers which are frequent in transcriptomics.

This first score can then be adjusted to reflect the reality. It's the case of WGCNA which base its adjustement on the [scale-free](https://en.wikipedia.org/wiki/Scale-free_network) property of gene networks. The distribution of the nodes degree in these networks follows a power law. Next step consists to select the best fitting power law to the correlations, so they can be adjusted by it in the end.

Another adjustement takes into account the [topology of the network](https://en.wikipedia.org/wiki/Network_topology). It holds trails to understand the underlying biological processes. In this case, it's the topological overlap[^1] of two nodes which is used to reflect it.

<!-- The built of our co-expression network goes through this sub-steps : -->
<!-- 1. Computing correlation between each pair of genes. -->
<!-- 2. Trying to fit a power law to the distribution of this correlations to adjust them by it. This results in a similarity score for each pair of genes. -->
<!-- 3. This score is itselft re-adjust by taking into acount the topology of the network. -->

```{r net_building}
# In order to fasten the example process here, we only take a sample of the genes
kuehne_expr_filtered <- kuehne_expr_filtered[, 1:1000]

net <- net_building(kuehne_expr_filtered, cor_func = "spearman", detailled_result = TRUE)
```

* Power selected : `r net$power`
* Fit of the power law to data ($R^2$) : `r net$fit_power`

### 4. Modules detection

At this point, our network is a [complete graph](https://en.wikipedia.org/wiki/Complete_graph) : all nodes are connected to all other nodes with different strengh. Some strong links are often localized around the same genes, allowing to observe groups of genes closely related. In co-expression networks this groups are called modules and assumed to be representatives of genes working together to a same set of function.

They can be detected using unsupervised learning (here hierarchical clustering) or other adapted clustering method. 

```{r modules_detection}
detection <- modules_detection(kuehne_expr_filtered, net$tom, merge_cut_height = 0.997, detailled_result = TRUE)
```

Since this operation tend to create multiple little modules with highly similar expression profile (based on the [eigengene](FAQ.html/#what-is-an-eigengene) of each), they are ussually merged into one.

* Number of modules before merging : `r length(unique(detection$modules_premerge))-1` 
* Number of modules after merging : `r length(unique(detection$modules))-1`

```{r bipartite_graph_merge}
plot_modules_merge(detection)
```

```{r plot_modules_gene_distribution}
ggplot2::ggplot(data.frame(module = detection$modules), ggplot2::aes(x = module)) + ggplot2::stat_count() +
  ggplot2::ylab("Number of genes")
```

As explain before, each module regroups genes which have a strong similarity. This means the expression profiles are also similar, as shown below.

```{r plot_module_profile}
plot_expression_profiles(kuehne_expr_filtered, detection)
```





### 5. Biological integration

#### 5.1. Functionnal enrichment

```{r modules_enrichment}
library(gprofiler2)
enrichment <- modules_enrichment(detection$modules)
```

* Example of  module 2 enrichment plot
```{r plot_enrichment, message = FALSE}
gprofiler2::gostplot(enrichment$`2`)
```

#### 5.2. Phenotypic association

```{r modules_phenotype}
phenotype_association <- modules_phenotype(detection$modules_eigengenes, kuehne_traits %>% select(Condition, Age, Slide))
```

```{r plot_modules_phenotype}
plot_modules_phenotype(phenotype_association)
```

<!-- ### 5.3. Differentially expressed genes (maybe ?) -->

### 6. Graph analysis

```{r graph}
# TODO

```


### 7. Modules comparison

```{r redo_by_condition, message=FALSE, results='hide'}
kuehne_traits$sample = apply(kuehne_traits, 1, function(line) paste(line["Slide"], line["Exp"], sep = "_"))
data_list <- list(
  kuehne_young = kuehne_expr_filtered[rownames(kuehne_expr_filtered) %in% kuehne_traits[which(kuehne_traits$Condition == "young"), "sample"],],
  kuehne_old = kuehne_expr_filtered[rownames(kuehne_expr_filtered) %in% kuehne_traits[which(kuehne_traits$Condition == "old"), "sample"],]  
)

net_list <- lapply(data_list, net_building, kuehne_expr_filtered, cor_func = "spearman", save_adjacency = TRUE, detailled_result = TRUE)
detection_list <- mapply(modules_detection, data_list, lapply(net_list, function(condition) condition$tom), SIMPLIFY = FALSE)
```

```{r modules_preservation}
preservation <- modules_preservation(data_list, net_list, detection_list, "kuehne_young", "kuehne_old")
preserved_modules <- which(apply(preservation$p.value, 1, max) < 0.999) # Fake value here, just to show the result
```

* Preservation statistics

`r knitr::kable(preservation$p.values)`

* Modules preserved : `r paste(preserved_modules, collapse = ", ")`



<div style="text-align:center; font-size:70%; margin-top:50px"> 
  ______
  If you have any question or misunderstanding, take a look at GWENA's general documentation (`package?GWENA`) or send an email to lemoine.gwenaelle[@t)gmail{d0t]com
</div>

<!-- ______ -->

[^1]: [RAVASZ, Erzsébet, SOMERA, Anna Lisa, MONGRU, Dale A., et al. Hierarchical organization of modularity in metabolic networks. science, 2002, vol. 297, no 5586, p. 1551-1555.](https://doi.org/10.1126/science.1073374)
