---
title: "GWENA - Tutorial"
author: "Gwenaëlle Lemoine"
date: "`r Sys.Date()`"
output: 
  # rmarkdown::html_vignette: 
  #   toc: true
  prettydoc::html_pretty:
    theme: cayman
    toc: true
vignette: >
  %\VignetteIndexEntry{GWENA-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>",
  cache = TRUE
)
```

<!-- *Citation: TODO when article published* -->

## Overview

Understanding of complex biological systems can now be improved through the harvest of large data-sets from high-throughput transcriptomics technologies. This however require approaches able to manage such amout of data. One can be to gene network analysis. Based on interactions study between each gene, their interpretation often involve both a knowledge-driven and a data driven analysis. Current methods focus on functional enrichment and hub genes detection, respectively. Combining them with the comparison of biological or experimental conditions and an extended analysis of the network topology within a single pipeline can lead to better results exploitation. 

This document gives an overview of the R package **GWENA** (Gene Whole co-Expression Network Analysis) which regroups this process into a single pipeline. This package aim to ease the work of scientists in their analysis of multiple conditions through the co-expression method for gene network analysis. Therefore discovery of meaningful biological conclusions can be helped.

Figure 1 details the steps involved in the current analysis pipeline. They will be detailed in the following sections.

.

> ![Figure 1. Analysis pipeline of GWENA, from expression data to characterization of the modules and comparison of conditions.](figure_pipeline_schema.png)

<!-- It can be performed using the function wrapping all steps `TODO nom fonction full analysis`, or using each function for each step. -->


<!-- ## Quick start  -->
<!-- `# TODO: script function full analysis when implemented` -->

<!-- ```{r wrapper, eval = FALSE} -->
<!-- # TODO: add example with wrapper -->
<!-- ``` -->

## Main steps detail with default pipeline

### 0. Starting with GWENA

Installation can either be from:

1. the official version from the last Bioconductor release (3.11 on R-4.0.0).
2. the last stable version from the Bioc Devel branch.
3. the day-to-day developpment version from the [github repository](https://github.com/Kumquatum/GWENA).

```{r install, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
  install.packages("BiocManager")

# 1. From Bioconductor release
BiocManager::install("GWENA")

# 2. From Bioconductor devel
BiocManager::install("GWENA", version = "devel")

# 3. From Github repository
BiocManager::install("Kumquatum/GWENA")
# OR
if (!requireNamespace("devtools", quietly=TRUE))
  install.packages("devtools")
devtools::install_github("Kumquatum/GWENA")

```

Then simply load GWENA as usual:

```{r load, message=FALSE, warning=FALSE}
library(GWENA)
library(magrittr) # Not mandatory, but in this tutorial we use the pipe `%>%` to ease readability
```

### 1. Input data

Expression data can either be from RNA-seq or microarray. You can use the import function of your choice (read.csv, read.table, etc.) as long as the final format is a data.frame with genes as columns and samples as rows. Transcriptomic data must have been reduced to the gene level (See [How can I resume my transcriptomic data to the gene level ?](FAQ.html/#how-can-i-reduce-my-transcriptomic-data-to-the-gene-level) from the [FAQ](FAQ.html)) since GWENA is deisgned to build **gene** co-expression networks. 

In this vignette, we will be using the transcriptomic dataset [GSE85358](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85358) from the [Kuehne et al. study](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-017-3547-3) and the associated phenotypic traits matrix. Microarray was an Agilent-039494 SurePrint G3 Human GE v2 8x60K, mono channel. These data were gathered in a context of skin aging study and been processed and normalized along with the R script given in [Additional data n°10](https://static-content.springer.com/esm/art%3A10.1186%2Fs12864-017-3547-3/MediaObjects/12864_2017_3547_MOESM10_ESM.zip). 

> Note: [GWENA doesn't provide normalization methods](FAQ.html/#).

```{r data_input}
# Number of genes
ncol(kuehne_expr)
# Number of samples
nrow(kuehne_expr)
# Conditions 
unique(kuehne_traits$Condition)

# Overview of expression table
kuehne_expr[1:5,1:5]
# Overview of traits table
kuehne_traits[1:5,]
```


### 2. Gene filtering

Even if the co-expression method is designed to manage and filter out low co-expressed genes, it is still interesting to reduce the dataset to work with. This step will allow to use less memory for data storage and less CPU power and memory for processing. However, filtering needs to be carefully studied as it will impact the gene modules building. 

Multiple types of filtration have been natively implemented :

* For RNA-seq and microarray:
  * Filtering on low variation of expression
* For RNA-seq data:
  * at least one: only one sample needs to have a value above minimal count threshold in the gene
  * mean: the means of all samples for the gene needs to be above min_count
  * all: all samples for the gene need to be above min_count
  
<!-- * For microarray: -->
<!--   * TODO if one is implemented one day -->

> Note: The authors of [WGCNA](https://cran.r-project.org/package=WGCNA)(used in GWENA for network building) advise [against using differentialy expressed (DE) genes](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html) as a filter since it method is based on unsupervised clustering. Moreover, using DE genes will break the scale-free property (small-world network) on which the adjacency matrix is calculated.

In this example, we will be filtering the low variable genes with `filter_low_var` function.

```{r filtration}
kuehne_expr_filtered <- filter_low_var(kuehne_expr, pct = 0.7, type = "median")

# Remaining number of genes
ncol(kuehne_expr_filtered)
```


### 3. Network building 

Gene co-expression networks are an ensemble of genes (nodes) linked to each other (edges) according to the strengh of their relation. This strength is estimated by the computation of a **(dis)similarity score** which can start with a distance (euclidian, minkowski, ...) but is usually a correlation. Among these, Pearson's one is the most popular, however in GWENA we select Spearman correlation by default. It is less sensible to outliers which are frequent in transcriptomics datasets and does not assume normal distribution of data.

Built of co-expression network goes through this sub-steps :

1. Computation of a **correlation** (or distance) between each pair of genes.
2. Fitting of a power law to the distribution of this correlations.
3. Computation of an **adjacency score** by adjusting previous correlation by the fitted power law. 
4. Computation of a **topological overlap score** by taking into account the topology of the network.

These successive adjustments improve the detection of modules for the next step.

```{r net_building}
# In order to fasten the example execution time, we only take an arbitary sample of the genes. 
kuehne_expr_filtered <- kuehne_expr_filtered[, 1:1000]

net <- build_net(kuehne_expr_filtered, cor_func = "spearman", n_threads = 2)

# Power selected :
net$metadata$power
# Fit of the power law to data ($R^2$) :
net$metadata$fit_power_table[net$metadata$fit_power_table$Power == net$metadata$power, "SFT.R.sq"]
```


### 4. Modules detection

At this point, the network is a [complete graph](https://en.wikipedia.org/wiki/Complete_graph): all nodes are connected to all other nodes with different strengths. Among the genes, groups of them are strongly related between multiple other. In co-expression networks these groups are called **modules** and assumed to be representative of genes working together to a same set of function.

They can be detected using unsupervised learning (here hierarchical clustering) or other adapted clustering method (kmeans, Gaussian mixture models, etc.). 

```{r modules_detection}
detection <- detect_modules(kuehne_expr_filtered, net$network, merge_cut_height = 0.997, detailled_result = TRUE)
```

**Important**: Module 0 is containing genes which did not fit into any module.

Since this operation tends to create multiple little modules with highly similar expression profile (based on the [eigengene](FAQ.html/#what-is-an-eigengene) of each), they are usually merged into one.

```{r bipartite_graph_merge}
# Number of modules before merging :
length(unique(detection$modules_premerge))
# Number of modules after merging: 
length(unique(detection$modules))

plot_modules_merge(modules_premerge = detection$modules_premerge, modules_merged = detection$modules)
```

Resulting modules contain more genes whose repartition can be seen by a simple barplot. Noticebly, WGCNA tend to create bigger modules for the first ones and smaller for the latest. 

```{r plot_modules_gene_distribution, fig.height=3}
ggplot2::ggplot(data.frame(detection$modules %>% stack), ggplot2::aes(x = ind)) + ggplot2::stat_count() +
  ggplot2::ylab("Number of genes") +
  ggplot2::xlab("Module")
```

Each of the modules present a distinct profile, which can be plotted in two figures to separate the positive (+ facet) and negative (- facet) correlations profile. As a summary of this profiles, an eigengene (red line) acting like a signature can be stacked on this representation. 

```{r plot_module_profile}
plot_expression_profiles(kuehne_expr_filtered, detection$modules)
```

These profile informations along with the genes sets inside modules are usefull to relate external gene information, or more generally, biological information.


### 5. Biological integration

#### 5.1. Functional enrichment

A popular way to explore the modules consist to link know biological gene sets to it. Among the available ones, [Gene Ontology (GO)](https://www.nature.com/articles/srep18871#ref-CR1) and the [Kyoto Encyclopedia of Genes and Genomes (KEGG)](https://www.nature.com/articles/srep18871#ref-CR2) are the more used. Along with [WikiPathways](https://doi.org/10.1093/nar/gkx1064), [Reactome](https://www.nature.com/articles/srep18871#ref-CR4), [Human Phenotype Ontology (HPO)](https://doi.org/10.1093%2Fnar%2Fgkt1026), they give a systemic aspect to the gene sets from the modules. In oppositions, references like [TRANSFAC](https://doi.org/10.1093%2Fbib%2Fbbn016), [miRTarBase](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3013699), [Human Protein Atlas (HPA)](https://dx.doi.org/10.1126%2Fscience.1260419), and [CORUM](http://www.ncbi.nlm.nih.gov/pubmed/30357367) give a more linear point of view but with a larger scale information like tissue/cell/condition information.

Using the [over-representation analysis (ORA)](http://doi.org/10.1371/journal.pcbi.1002375) tool [GOSt](https://biit.cs.ut.ee/gprofiler/gost) from g:Profiler, we can retieve the biological association for each module and plot it as follow.

```{r modules_enrichment}
enrichment <- bio_enrich(detection$modules)
plot_enrichment(enrichment)
```

With this information, preliminary information can be retrieved. For example, module 2 functional activity seems to be linked to the processes of membrane communication.

#### 5.2. Phenotypic association

If phenotypic information is available about the samples provided, an association test can help to determine if a module is specifically linked to a trait. In this case, module 1 seems to be strongly linked to the `Age` trait.

```{r modules_phenotype}
phenotype_association <- associate_phenotype(detection$modules_eigengenes, 
                                             kuehne_traits %>% dplyr::select(Condition, Age, Slide))
plot_modules_phenotype(phenotype_association)
```

The combination of information with the previous functional enrichment can guide further analysis. Ex: aging is a condition related to the variations of the cell potential: the progressive degradation of quality in cell proliferation and differentiation is the first steps towards malfunctions which induce tissue degradation.

<!-- ### 5.3. differentialy expressed genes (maybe ?) -->

### 6. Graph analysis

Information can be retrieved from the network itself. For example, hub genes are genes highly connected known to be associated with key biological functions. They can be detected by different methods :

* Highest connectivity: Select the top n (n depending on parameter given) highest connected genes. Similar to WGCNA's selection of hub genes
* Superior degree: Select genes which degree is greater than average connection degree of the network. Definition from network theory.
* Kleinberg's score: Select genes which Kleinberg's score superior to provided threshold.

Manipulation of graph objects can be quite demanding in memory and CPU usage. Caution is advised when choosing to plot the whole network if it is larger than 100 genes. 
Since a co-expression network is a complete graph, readability is hard because of all beeing connected with each other. In order to clarity visualization, edges with a similarity score below a threshold are removed.

```{r graph}
module_2 <- detection$modules$`2`
graph <- build_graph_from_sq_mat(net$network[module_2, module_2])
plot_module(graph, weight_th = 0.99999)
```


### 7. Comparison of conditions

Co-expression networks can be compared between conditions to detect differences of patterns of co-expression. These may indicate break of inhibition, inefficiency of a factor of transcription, etc. Depending on the study, one might want to focus on the modules preserved between conditions, or the unpreserved one. For example, if you're looking for housekeeping genes, you should test for the modules preserved; but if you're looking for the genes that drive a disease, you should test for the unpreserved ones.

GWENA use a comparison test based on random re-assignment of gene names inside module to see whether patterns inside modules change (from [NetRep](https://cran.r-project.org/web/packages/NetRep/vignettes/NetRep.html) package). This permutation test is repeated a large number of time to ensure the significance of the result.

In order to achieve comparison, build of the network and detection of the modules need to be performed for each condition. Saving cpu, memory and time, can be achieve by switching the parameter `keep_cor_mat` from the `build_net` function to TRUE so the similarity matrix is kept in the returned object.

```{r condition_comparison}
samples_by_cond <- sapply(kuehne_traits$Condition %>% unique, function(cond){
  apply(kuehne_traits[which(kuehne_traits$Condition == cond), c("Slide", "Exp")], 1, paste, collapse = "_")
}, simplify = FALSE)
  
expr_by_cond <- sapply(samples_by_cond %>% names, function(cond){
  kuehne_expr_filtered[which(rownames(kuehne_expr_filtered) %in% samples_by_cond[[cond]]),]
}, simplify = FALSE)

net_by_cond <- lapply(expr_by_cond, build_net, cor_func = "spearman", n_threads = 2, keep_cor_mat = TRUE)
mod_by_cond <- mapply(detect_modules, expr_by_cond, lapply(net_by_cond, `[[`, "network"), 
                      MoreArgs = list(merge_cut_height = 0.997, detailled_result = TRUE), SIMPLIFY = FALSE)

comparison <- compare_conditions(expr_by_cond, 
                                 lapply(net_by_cond, `[[`, "network"), 
                                 lapply(net_by_cond, `[[`, "cor_mat"),  
                                 lapply(mod_by_cond, `[[`, "modules"),
                                 comparison_type = "preserved", 
                                 pvalue_th = 0.05)
```

The final object contains a table resuming the comparison of the module, directly available with `comparison$result$young$old$comparison`

`r knitr::kable(comparison$result$young$old$comparison, caption =  "Modules preservation with young as reference")`

The detail of the statistics pvalues can also be seen as a heatmap. Since all statistics need to be significant to consider a module preserved/unpreserved/one of them, it can be interesting to see which statistics prevented a module to be significant.

```{r plot_comparison_stats}
plot_comparison_stats(comparison$result$young$old$p.values)
```

<!-- Comparison can also be done with more than 2 conditions. In that case, we can do a cross comparison with each condition as reference, and see the proportion of modules preserved for exemple between each one. -->
<!-- Inserer heatmap avec les proportions de modules conservés -->



<!-- ## The modularity of GWENA -->

<!-- This package as been designed as a fully modular pipeline. By this, we mean that any step of the pipeline as described before, can be performed by another software or package you would prefere. For exemple, other methodes for co-expression network building and module detection exists. You could  -->


<div style="text-align:center; font-size:70%; margin-top:50px"> 
  ______
  If you have any question or misunderstanding, take a look at GWENA's general documentation (`package?GWENA`) or send an email to lemoine.gwenaelle[@t)gmail{d0t]com
</div>

<!-- ______ -->

[^1]: [RAVASZ, Erzsébet, SOMERA, Anna Lisa, MONGRU, Dale A., et al. Hierarchical organization of modularity in metabolic networks. science, 2002, vol. 297, no 5586, p. 1551-1555.](https://doi.org/10.1126/science.1073374)
